<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YOLO Checker - Juxtapose View</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        #app-root { display: flex; width: 100vw; height: 100vh; }

        /* SIDEBAR */
        .sidebar { 
            width: 300px; 
            background: #f8f9fa; 
            border-right: 1px solid #ddd; 
            padding: 20px; 
            display: flex; 
            flex-direction: column; 
            z-index: 10; 
            height: 100%; 
            box-sizing: border-box; 
            flex-shrink: 0;
        }
        .sidebar-content { flex: 1; overflow-y: auto; display: flex; flex-direction: column; }

        /* STAGE - COMPARED VIEW */
        .stage { 
            flex: 1; 
            background: #222; 
            display: flex; 
            flex-direction: column;
            overflow: hidden; 
            position: relative; 
        }
        .stage.dragging { background: #333; border: 4px dashed #007bff; }

        /* SPLIT LAYOUT */
        .compare-container {
            display: flex;
            flex: 1;
            width: 100%;
            height: 100%;
            padding: 20px;
            box-sizing: border-box;
            gap: 20px;
            align-items: center;
            justify-content: center;
        }

        .view-pane {
            flex: 1;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            min-width: 0;
        }

        .pane-label {
            color: #888;
            text-transform: uppercase;
            font-size: 0.8rem;
            font-weight: bold;
            margin-bottom: 10px;
            letter-spacing: 1px;
            text-align: center;
        }

        /* CANVAS WRAPPERS */
        .canvas-wrapper { 
            position: relative; 
            box-shadow: 0 0 10px rgba(0,0,0,0.5); 
            line-height: 0; 
            user-select: none; 
            width: fit-content; 
            max-width: 100%; 
            max-height: 90%; 
            display: flex;
        }

        .target-image { 
            display: block; 
            max-width: 100%; 
            max-height: 85vh; 
            object-fit: contain; 
        }

        /* INTERACTION STYLES */
        .canvas-wrapper.interactive { cursor: crosshair; border: 1px solid #444; }
        .canvas-wrapper.read-only { cursor: default; opacity: 0.9; border: 1px solid #444; }

        /* UI ELEMENTS */
        h2 { margin-top: 0; font-size: 1.2rem; color: #333; margin-bottom: 10px;}
        h3 { font-size: 0.85rem; text-transform: uppercase; color: #888; margin: 15px 0 5px 0; font-weight: 700; letter-spacing: 0.5px; }
        
        .btn { padding: 8px 12px; cursor: pointer; border: none; border-radius: 4px; color: white; font-weight: bold; width: 100%; margin-top: 5px; font-size: 13px; transition: opacity 0.2s; }
        .btn:hover { opacity: 0.9; }
        .btn-green { background: #28a745; }
        .btn-blue { background: #007bff; }
        .btn-red { background: #dc3545; }
        .btn-outline { background: transparent; border: 1px solid #ccc; color: #666; }
        .btn-outline:hover { background: #eee; }

        input[type="text"] { padding: 6px; border: 1px solid #ccc; border-radius: 4px; width: 100%; box-sizing: border-box; }
        
        /* CLASS LIST */
        .class-item { padding: 6px 10px; border: 1px solid #ddd; background: white; margin-bottom: 4px; cursor: pointer; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; font-size: 13px; }
        .class-item.active { border-color: #007bff; background: #e7f1ff; }
        
        /* QUEUE LIST */
        .queue-item { padding: 8px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; font-size: 12px; cursor: pointer; background: white; }
        .queue-item:hover { background: #f1f1f1; }
        .queue-item.active { background: #e7f1ff; border-left: 3px solid #007bff; }
        .badge { padding: 2px 5px; border-radius: 3px; font-size: 10px; background: #eee; color: #666; }
        .badge.has-csv { background: #d4edda; color: #155724; }

        /* BOXES */
        .bounding-box { position: absolute; border-width: 2px; border-style: solid; }
        .bounding-box:hover { background-color: rgba(255,255,255,0.2); z-index: 10; }
        .box-label { position: absolute; top: -18px; left: -2px; color: white; font-size: 11px; font-weight: bold; padding: 1px 4px; white-space: nowrap; pointer-events: none; text-shadow: 0px 0px 2px black;}
        .delete-box-btn { position: absolute; top: -10px; right: -10px; width: 18px; height: 18px; background: red; color: white; border-radius: 50%; border: 2px solid white; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 12px; z-index: 20; }
        
        .empty-state { color: #aaa; text-align: center; border: 2px dashed #555; padding: 40px; border-radius: 10px; line-height: 1.5; margin: auto;}
        
        /* CSV Settings */
        .settings-panel { background: #eee; padding: 10px; border-radius: 4px; margin-top: 5px; font-size: 11px; border: 1px solid #ddd; }
        .settings-row { display: flex; justify-content: space-between; margin-bottom: 3px; align-items: center; }
        .settings-row label { width: 70px; }
        .settings-row input { flex: 1; padding: 2px; }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">
    const { useState, useRef, useEffect } = React;

    function getColor(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) hash = str.charCodeAt(i) + ((hash << 5) - hash);
        const c = (hash & 0x00ffffff).toString(16).toUpperCase();
        return '#' + '00000'.substring(0, 6 - c.length) + c;
    }

    function App() {
        // --- DATA STATE ---
        const [queue, setQueue] = useState([]);
        const [currentIndex, setCurrentIndex] = useState(-1);
        
        const [classes, setClasses] = useState(() => {
            const saved = localStorage.getItem('yolo-tagger-classes');
            return saved ? JSON.parse(saved) : [];
        });

        // --- UI STATE ---
        const [activeClass, setActiveClass] = useState(null);
        const [newClassInput, setNewClassInput] = useState("");
        const [isDrawing, setIsDrawing] = useState(false);
        const [startPos, setStartPos] = useState(null); 
        const [currentBox, setCurrentBox] = useState(null);
        const [isDraggingFile, setIsDraggingFile] = useState(false);
        const [showCsvSettings, setShowCsvSettings] = useState(false);
        
        const [csvHeaders, setCsvHeaders] = useState({
            className: "class_name", xCenter: "x_center", yCenter: "y_center", width: "width", height: "height"
        });

        // We only attach interaction logic to the Annotated container
        const annotatedContainerRef = useRef(null);

        // --- EFFECTS ---
        useEffect(() => { localStorage.setItem('yolo-tagger-classes', JSON.stringify(classes)); }, [classes]);

        const currentItem = currentIndex >= 0 && queue[currentIndex] ? queue[currentIndex] : null;
        const currentBoxes = currentItem ? currentItem.boxes : [];

        // --- BATCH LOADING LOGIC ---
        const handleDrop = (e) => {
            e.preventDefault();
            setIsDraggingFile(false);
            
            const files = Array.from(e.dataTransfer.files);
            if (files.length === 0) return;

            const imageFiles = files.filter(f => f.type.startsWith('image/'));
            const csvFiles = files.filter(f => f.name.toLowerCase().endsWith('.csv') || f.type === 'text/csv');

            if (imageFiles.length === 0 && csvFiles.length > 0 && queue.length > 0) {
                attachCsvsToQueue(csvFiles);
                return;
            }

            const newItems = imageFiles.map(img => {
                const baseName = img.name.substring(0, img.name.lastIndexOf('.'));
                const match = csvFiles.find(c => c.name.startsWith(baseName));
                
                return {
                    id: baseName,
                    file: img,
                    csvFile: match || null,
                    boxes: [],
                    imageSrc: URL.createObjectURL(img),
                    isParsed: false 
                };
            });

            if (newItems.length > 0) {
                setQueue(prev => [...prev, ...newItems]);
                if (currentIndex === -1) {
                    setCurrentIndex(0);
                    if (newItems[0].csvFile) parseQueueItemCsv(newItems[0], 0);
                }
            } else {
                alert("No images found in drop.");
            }
        };

        const attachCsvsToQueue = (csvFiles) => {
            const updatedQueue = [...queue];
            let attached = 0;
            csvFiles.forEach(csv => {
                const baseName = csv.name.split('.')[0].replace('_annotations', '');
                const index = updatedQueue.findIndex(q => q.id === baseName || q.file.name.startsWith(baseName));
                if (index !== -1) {
                    updatedQueue[index].csvFile = csv;
                    updatedQueue[index].isParsed = false; 
                    attached++;
                    if (index === currentIndex) parseQueueItemCsv(updatedQueue[index], index);
                }
            });
            setQueue(updatedQueue);
            alert(`Attached ${attached} CSVs to existing images.`);
        };

        const parseQueueItemCsv = (item, index) => {
            if (!item.csvFile) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const text = e.target.result;
                const { parsedBoxes, newClasses } = parseCsvText(text);
                
                if (newClasses.length > 0) {
                    setClasses(prev => Array.from(new Set([...prev, ...newClasses])));
                    if (!activeClass) setActiveClass(newClasses[0]);
                }

                setQueue(prevQueue => {
                    const newQ = [...prevQueue];
                    newQ[index] = { ...newQ[index], boxes: parsedBoxes, isParsed: true };
                    return newQ;
                });
            };
            reader.readAsText(item.csvFile);
        };

        const parseCsvText = (text) => {
            const lines = text.trim().split('\n');
            if (lines.length < 2) return { parsedBoxes: [], newClasses: [] };

            const headerLine = lines[0].split(',').map(h => h.trim());
            const getIdx = (key) => headerLine.indexOf(csvHeaders[key]);
            
            const idxName = getIdx('className');
            const idxX = getIdx('xCenter');
            const idxY = getIdx('yCenter');
            const idxW = getIdx('width');
            const idxH = getIdx('height');

            if (idxX === -1) return { parsedBoxes: [], newClasses: [] };

            const parsedBoxes = [];
            const foundClasses = new Set();

            for (let i = 1; i < lines.length; i++) {
                const row = lines[i].split(',').map(c => c.trim());
                if (row.length < headerLine.length) continue;

                const className = idxName !== -1 ? row[idxName] : "Unknown";
                const xc = parseFloat(row[idxX]);
                const yc = parseFloat(row[idxY]);
                const w = parseFloat(row[idxW]);
                const h = parseFloat(row[idxH]);

                if (isNaN(xc)) continue;

                if (className) foundClasses.add(className);

                const x = xc - (w / 2);
                const y = yc - (h / 2);

                parsedBoxes.push({
                    id: Date.now() + i,
                    x: Math.max(0, x),
                    y: Math.max(0, y),
                    w: w,
                    h: h,
                    label: className
                });
            }
            return { parsedBoxes, newClasses: Array.from(foundClasses) };
        };

        // --- NAVIGATION & UPDATES ---
        const switchImage = (newIndex) => {
            if (newIndex < 0 || newIndex >= queue.length) return;
            setCurrentIndex(newIndex);
            
            const target = queue[newIndex];
            if (target.csvFile && !target.isParsed) {
                parseQueueItemCsv(target, newIndex);
            }
        };

        const updateCurrentBoxes = (newBoxes) => {
            setQueue(prev => {
                const copy = [...prev];
                copy[currentIndex] = { ...copy[currentIndex], boxes: newBoxes };
                return copy;
            });
        };

        // --- DRAWING (Only attached to Annotated Side) ---
        const getRelativeCoords = (e) => {
            if (!annotatedContainerRef.current) return null;
            const rect = annotatedContainerRef.current.getBoundingClientRect();
            return {
                x: Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width)),
                y: Math.max(0, Math.min(1, (e.clientY - rect.top) / rect.height))
            };
        };

        const handleMouseDown = (e) => {
            if (e.button !== 0 || !activeClass) return;
            const coords = getRelativeCoords(e);
            if(!coords) return;
            setIsDrawing(true);
            setStartPos(coords);
        };

        const handleMouseMove = (e) => {
            if (!isDrawing || !startPos) return;
            const coords = getRelativeCoords(e);
            const x = Math.min(coords.x, startPos.x);
            const y = Math.min(coords.y, startPos.y);
            const w = Math.abs(coords.x - startPos.x);
            const h = Math.abs(coords.y - startPos.y);
            setCurrentBox({ x, y, w, h, label: activeClass });
        };

        const handleMouseUp = () => {
            if (currentBox && currentBox.w > 0.005 && currentBox.h > 0.005) {
                const newB = { ...currentBox, id: Date.now() };
                updateCurrentBoxes([...currentBoxes, newB]);
            }
            setIsDrawing(false);
            setStartPos(null);
            setCurrentBox(null);
        };

        const deleteBox = (id) => {
            updateCurrentBoxes(currentBoxes.filter(b => b.id !== id));
        };

        // --- EXPORT ---
        const exportCurrent = () => {
            if (!currentItem || currentBoxes.length === 0) {
                alert("Nothing to export for this image.");
                return;
            }
            
            let csvContent = "class_id,class_name,x_center,y_center,width,height\n";
            currentBoxes.forEach(box => {
                const x_center = box.x + (box.w / 2);
                const y_center = box.y + (box.h / 2);
                const classIdx = classes.indexOf(box.label);
                // Ensure we handle cases where classIdx is -1 (class not found)
                const safeClassIdx = classIdx === -1 ? 0 : classIdx; 
                
                csvContent += `${safeClassIdx},${box.label},${x_center.toFixed(6)},${y_center.toFixed(6)},${box.w.toFixed(6)},${box.h.toFixed(6)}\n`;
            });

            // 1. Add charset to MIME type
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;

            // Use the same base name as the input image (just change extension to .csv)
            const imageName = currentItem.file && currentItem.file.name ? currentItem.file.name : `${currentItem.id}.png`;
            const baseName = imageName.replace(/\.[^/.]+$/, "");
            link.download = `${baseName}.csv`;

            // 2. CRITICAL FIX: Append to body before clicking
            // Browsers often block clicks on elements that aren't in the DOM
            document.body.appendChild(link);
            link.click();
            
            // 3. Clean up
            document.body.removeChild(link);
            URL.revokeObjectURL(url); // Free up memory
        };

        const handleSaveAndNext = () => {
            exportCurrent();
            if (currentIndex < queue.length - 1) {
                switchImage(currentIndex + 1);
            } else {
                alert("Done! That was the last image.");
            }
        };

        const handleReset = () => {
            if(confirm("Clear entire queue?")) {
                setQueue([]);
                setCurrentIndex(-1);
            }
        };

        // --- MANAGERS ---
        const handleAddClass = () => {
            const val = newClassInput.trim();
            if(!val || classes.includes(val)) return;
            const newClasses = [...classes, val];
            setClasses(newClasses);
            setNewClassInput("");
            if(!activeClass) setActiveClass(val);
        };

        const updateCsvHeaderSetting = (key, val) => {
            setCsvHeaders(prev => ({ ...prev, [key]: val }));
        };

        const handleDragOver = (e) => { e.preventDefault(); setIsDraggingFile(true); };
        const handleDragLeave = (e) => { e.preventDefault(); setIsDraggingFile(false); };

        return (
            <div id="app-root">
                {/* SIDEBAR */}
                <div className="sidebar">
                    <h2>YOLO Checker <span style={{fontSize:'0.6em', color:'#888'}}>View</span></h2>
                    <a href="index.html" className="btn btn-outline" style={{textDecoration: 'none', display: 'block', textAlign: 'center', marginBottom: 10}}>← Back to Dashboard</a>
                    
                    <div className="sidebar-content">
                        {/* 1. QUEUE LIST */}
                        <h3>1. File Queue ({queue.length})</h3>
                        <div style={{flex: 1, maxHeight: '200px', overflowY: 'auto', border: '1px solid #ddd', background: 'white', borderRadius: 4}}>
                            {queue.length === 0 && <div style={{padding:10, color:'#ccc', fontStyle:'italic', fontSize:12}}>Drag & Drop multiple files here</div>}
                            {queue.map((item, idx) => (
                                <div key={idx} 
                                    className={`queue-item ${currentIndex === idx ? 'active' : ''}`}
                                    onClick={() => switchImage(idx)}
                                >
                                    <div style={{overflow:'hidden', textOverflow:'ellipsis', whiteSpace:'nowrap', maxWidth:'180px'}}>
                                        {idx + 1}. {item.file.name}
                                    </div>
                                    <div style={{display:'flex', gap:2}}>
                                        {item.csvFile && <span className="badge has-csv" title="CSV Loaded">CSV</span>}
                                        {item.boxes.length > 0 && <span className="badge">{item.boxes.length}</span>}
                                    </div>
                                </div>
                            ))}
                        </div>
                        
                        <div style={{display:'flex', gap: 5, marginTop: 5}}>
                            <button className="btn btn-outline" onClick={() => switchImage(currentIndex - 1)} disabled={currentIndex <= 0}>Prev</button>
                            <button className="btn btn-outline" onClick={() => switchImage(currentIndex + 1)} disabled={currentIndex >= queue.length - 1}>Next</button>
                        </div>

                        {/* 2. CSV SETTINGS */}
                        <div style={{marginTop: 15}}>
                            <button className="btn btn-outline" style={{padding: '4px', fontSize: 10, width: 'auto'}} 
                                    onClick={() => setShowCsvSettings(!showCsvSettings)}>
                                {showCsvSettings ? "Hide CSV Settings" : "CSV Column Mapping..."}
                            </button>
                            {showCsvSettings && (
                                <div className="settings-panel">
                                    <div className="settings-row"><label>Class:</label><input value={csvHeaders.className} onChange={e=>updateCsvHeaderSetting('className', e.target.value)} /></div>
                                    <div className="settings-row"><label>Center X:</label><input value={csvHeaders.xCenter} onChange={e=>updateCsvHeaderSetting('xCenter', e.target.value)} /></div>
                                    <div className="settings-row"><label>Center Y:</label><input value={csvHeaders.yCenter} onChange={e=>updateCsvHeaderSetting('yCenter', e.target.value)} /></div>
                                    <div className="settings-row"><label>Width:</label><input value={csvHeaders.width} onChange={e=>updateCsvHeaderSetting('width', e.target.value)} /></div>
                                    <div className="settings-row"><label>Height:</label><input value={csvHeaders.height} onChange={e=>updateCsvHeaderSetting('height', e.target.value)} /></div>
                                </div>
                            )}
                        </div>

                        {/* 3. CLASSES */}
                        <h3>3. Classes</h3>
                        <div style={{display:'flex', gap:5, marginBottom: 5}}>
                            <input value={newClassInput} onChange={e => setNewClassInput(e.target.value)} placeholder="Add Class..." onKeyDown={(e) => e.key === 'Enter' && handleAddClass()} />
                            <button className="btn-blue" style={{width:'auto'}} onClick={handleAddClass}>+</button>
                        </div>
                        <div style={{flex: 1, minHeight: '100px', overflowY: 'auto', border: '1px solid #eee', borderRadius: 4, padding: 2}}>
                            {classes.map((c, i) => (
                                <div key={c} className={`class-item ${activeClass === c ? 'active' : ''}`} onClick={() => setActiveClass(c)}>
                                    <div style={{display:'flex', alignItems:'center', gap: 8}}>
                                        <div style={{width:12, height:12, background: getColor(c), borderRadius: 2}}></div>
                                        <span>{c}</span>
                                    </div>
                                    <span style={{color:'#ccc', fontSize:10}}>({i})</span>
                                </div>
                            ))}
                        </div>
                        
                        <div style={{marginTop: 10}}>
                            <button className="btn btn-green" onClick={handleSaveAndNext}>Save & Next &rarr;</button>
                            <button className="btn btn-red" style={{marginTop: 10}} onClick={handleReset}>Reset All</button>
                        </div>
                    </div>
                </div>

                {/* STAGE */}
                <div className={`stage ${isDraggingFile ? 'dragging' : ''}`}
                    onDrop={handleDrop} onDragOver={handleDragOver} onDragLeave={handleDragLeave}>
                    
                    {currentItem ? (
                        <div className="compare-container">
                            
                            {/* LEFT: ANNOTATED (INTERACTIVE) */}
                            <div className="view-pane">
                                <div className="pane-label">Annotated (Edit Here)</div>
                                <div className="canvas-wrapper interactive" 
                                    ref={annotatedContainerRef}
                                    onMouseDown={handleMouseDown} 
                                    onMouseMove={handleMouseMove} 
                                    onMouseUp={handleMouseUp}
                                    style={{ cursor: activeClass ? 'crosshair' : 'default' }}>
                                    
                                    <img src={currentItem.imageSrc} className="target-image" draggable={false} />
                                    
                                    {/* RENDER BOXES */}
                                    {currentBoxes.map(box => {
                                        const color = getColor(box.label);
                                        return (
                                            <div key={box.id} className="bounding-box" style={{
                                                left: `${box.x * 100}%`, top: `${box.y * 100}%`, width: `${box.w * 100}%`, height: `${box.h * 100}%`,
                                                borderColor: color, backgroundColor: `${color}33`
                                            }}>
                                                <div className="box-label" style={{background: color}}>{box.label}</div>
                                                <div className="delete-box-btn" onClick={(e) => { e.stopPropagation(); deleteBox(box.id); }}>×</div>
                                            </div>
                                        );
                                    })}
                                    
                                    {/* DRAWING PREVIEW */}
                                    {currentBox && <div className="bounding-box" style={{
                                        left: `${currentBox.x * 100}%`, top: `${currentBox.y * 100}%`, width: `${currentBox.w * 100}%`, height: `${currentBox.h * 100}%`,
                                        borderColor: 'white', borderStyle: 'dashed', boxShadow: '0 0 4px rgba(0,0,0,0.5)'
                                    }} />}
                                </div>
                            </div>

                            {/* RIGHT: ORIGINAL (READ ONLY) */}
                            <div className="view-pane">
                                <div className="pane-label">Original</div>
                                <div className="canvas-wrapper read-only">
                                    <img src={currentItem.imageSrc} className="target-image" draggable={false} />
                                </div>
                            </div>

                        </div>
                    ) : (
                        <div className="empty-state">
                            <h3>Juxtapose Check Mode</h3>
                            <p>Drag & Drop images and CSVs<br/>to compare original vs annotated.</p>
                        </div>
                    )}
                </div>
            </div>
        );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>

</body>
</html>